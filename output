Murphi Code:
Patterns:
--- encrypt and decrypt rules of pat: aenc(Na.A,pk(B)), for intruder
ruleset i:indexType do 
  rule "decrypt 5"	---pat5
    i<=pat5Set.length & Spy_known[pat5Set.content[i]] &
    !Spy_known[msgs[pat5Set.content[i]].aencMsg]
    ==>
    var key_inv:Message;
	msgPat3:indexType;
	flag_pat3:boolean;
    begin
      key_inv := inverseKey(msgs[msgs[pat5Set.content[i]].aencKey]);
      if (key_inv.k.ag = intruderType) then
        Spy_known[msgs[pat5Set.content[i]].aencMsg]:=true;
        msgPat3:=msgs[pat5Set.content[i]].aencMsg;
        isPat3(msgs[msgPat3],flag_pat3);
        if (flag_pat3) then
          if (!exist(pat3Set,msgPat3)) then
            pat3Set.length:=pat3Set.length+1;
            pat3Set.content[pat3Set.length]:=msgPat3;
          endif;
        endif;
      endif;
    end;
endruleset;

ruleset i:indexType do 
  ruleset j:indexType do 
    rule "encrypt 5"	---pat5
      i<=pat3Set.length & Spy_known[pat3Set.content[i]] &
      j<=pat4Set.length & Spy_known[pat4Set.content[j]] &
      !Spy_known[construct5By34(pat3Set.content[i],pat4Set.content[j])]
      ==>
      var encMsgNo:indexType;
	  ---encMsg:Message;
      begin
        if (msgs[pat4Set.content[j]].k.ag=intruder.B) then
          encMsgNo := construct5By34(pat3Set.content[i],pat4Set.content[j]);
          if (!exist(pat5Set,encMsgNo)) then
            pat5Set.length := pat5Set.length+1;
            pat5Set.content[pat5Set.length]:=encMsgNo;
          endif;
          if (!Spy_known[encMsgNo]) then
            Spy_known[encMsgNo] := true;
          endif;
        endif;
      end;
    end;
  endruleset;
endruleset;

--- enconcat and deconcat rules for pat: concat(Na.A)

ruleset i:indexType do 
  rule "deconcat 3"	---pat3
    i<=pat3Set.length & Spy_known[pat3Set.content[i]] &
    !(Spy_known[msgs[pat3Set.content[i]].concatPart1] & Spy_known[msgs[pat3Set.content[i]].concatPart2])
    ==>
    var msgPat1,msgPat2:indexType;
        flag_pat1,flag_pat2:boolean;
    begin
      if (!Spy_known[msgs[pat3Set.content[i]].concatPart1]) then
        Spy_known[msgs[pat3Set.content[i]].concatPart1]:=true;
        msgPat1 := msgs[pat3Set.content[i]].concatPart1;
        isPat1(msgs[msgPat1],flag_pat1);
        if (flag_pat1) then
          if(!exist(pat1Set,msgPat1)) then
             pat1Set.length:=pat1Set.length+1;
             pat1Set.content[pat1Set.length] := msgPat1;
          endif;
        endif;
      endif;
      if (!Spy_known[msgs[pat3Set.content[i]].concatPart2]) then
        Spy_known[msgs[pat3Set.content[i]].concatPart2]:=true;
        msgPat2 := msgs[pat3Set.content[i]].concatPart2;
        isPat2(msgs[msgPat2],flag_pat2);
        if (flag_pat2) then
          if(!exist(pat2Set,msgPat2)) then
             pat2Set.length:=pat2Set.length+1;
             pat2Set.content[pat2Set.length] := msgPat2;
          endif;
        endif;
      endif;
    end;
endruleset;

ruleset i:indexType do 
  ruleset j:indexType do 
    rule "enconcat 3"	---pat3
      i<=pat1Set.length & Spy_known[pat1Set.content[i]] &
      j<=pat2Set.length & Spy_known[pat2Set.content[j]] &
      !Spy_known[construct3By12(pat1Set.content[i],pat2Set.content[j])]
      ==>
      var concatMsgNo:indexType;
      begin
        concatMsgNo := construct3By12(pat1Set.content[i],pat2Set.content[j]);
        Spy_known[concatMsgNo]:=true;
        if (!exist(pat3Set,concatMsgNo)) then
          pat3Set.length:=pat3Set.length+1;
          pat3Set.content[pat3Set.length]:=concatMsgNo;
        endif;
      end;
  endruleset;
endruleset;

--- encrypt and decrypt rules of pat: aenc(Na.Nb,pk(A)), for intruder
ruleset i:indexType do 
  rule "decrypt 7"	---pat7
    i<=pat7Set.length & Spy_known[pat7Set.content[i]] &
    !Spy_known[msgs[pat7Set.content[i]].aencMsg]
    ==>
    var key_inv:Message;
	msgPat6:indexType;
	flag_pat6:boolean;
    begin
      key_inv := inverseKey(msgs[msgs[pat7Set.content[i]].aencKey]);
      if (key_inv.k.ag = intruderType) then
        Spy_known[msgs[pat7Set.content[i]].aencMsg]:=true;
        msgPat6:=msgs[pat7Set.content[i]].aencMsg;
        isPat6(msgs[msgPat6],flag_pat6);
        if (flag_pat6) then
          if (!exist(pat6Set,msgPat6)) then
            pat6Set.length:=pat6Set.length+1;
            pat6Set.content[pat6Set.length]:=msgPat6;
          endif;
        endif;
      endif;
    end;
endruleset;

ruleset i:indexType do 
  ruleset j:indexType do 
    rule "encrypt 7"	---pat7
      i<=pat6Set.length & Spy_known[pat6Set.content[i]] &
      j<=pat4Set.length & Spy_known[pat4Set.content[j]] &
      !Spy_known[construct7By64(pat6Set.content[i],pat4Set.content[j])]
      ==>
      var encMsgNo:indexType;
	  ---encMsg:Message;
      begin
        if (msgs[pat4Set.content[j]].k.ag=intruder.B) then
          encMsgNo := construct7By64(pat6Set.content[i],pat4Set.content[j]);
          if (!exist(pat7Set,encMsgNo)) then
            pat7Set.length := pat7Set.length+1;
            pat7Set.content[pat7Set.length]:=encMsgNo;
          endif;
          if (!Spy_known[encMsgNo]) then
            Spy_known[encMsgNo] := true;
          endif;
        endif;
      end;
    end;
  endruleset;
endruleset;

--- enconcat and deconcat rules for pat: concat(Na.Nb)

ruleset i:indexType do 
  rule "deconcat 6"	---pat6
    i<=pat6Set.length & Spy_known[pat6Set.content[i]] &
    !(Spy_known[msgs[pat6Set.content[i]].concatPart1] & Spy_known[msgs[pat6Set.content[i]].concatPart2])
    ==>
    var msgPat11,msgPat12:indexType;
        flag_pat11,flag_pat12:boolean;
    begin
      if (!Spy_known[msgs[pat6Set.content[i]].concatPart1]) then
        Spy_known[msgs[pat6Set.content[i]].concatPart1]:=true;
        msgPat11 := msgs[pat6Set.content[i]].concatPart1;
        isPat1(msgs[msgPat11],flag_pat11);
        if (flag_pat11) then
          if(!exist(pat1Set,msgPat11)) then
             pat1Set.length:=pat1Set.length+1;
             pat1Set.content[pat1Set.length] := msgPat11;
          endif;
        endif;
      endif;
      if (!Spy_known[msgs[pat6Set.content[i]].concatPart2]) then
        Spy_known[msgs[pat6Set.content[i]].concatPart2]:=true;
        msgPat12 := msgs[pat6Set.content[i]].concatPart2;
        isPat1(msgs[msgPat12],flag_pat12);
        if (flag_pat12) then
          if(!exist(pat1Set,msgPat12)) then
             pat1Set.length:=pat1Set.length+1;
             pat1Set.content[pat1Set.length] := msgPat12;
          endif;
        endif;
      endif;
    end;
endruleset;

ruleset i:indexType do 
  ruleset j:indexType do 
    rule "enconcat 6"	---pat6
      i<=pat1Set.length & Spy_known[pat1Set.content[i]] &
      j<=pat1Set.length & Spy_known[pat1Set.content[j]] &
      i != j & 
      !Spy_known[construct6By11(pat1Set.content[i],pat1Set.content[j])]
      ==>
      var concatMsgNo:indexType;
      begin
        concatMsgNo := construct6By11(pat1Set.content[i],pat1Set.content[j]);
        Spy_known[concatMsgNo]:=true;
        if (!exist(pat6Set,concatMsgNo)) then
          pat6Set.length:=pat6Set.length+1;
          pat6Set.content[pat6Set.length]:=concatMsgNo;
        endif;
      end;
  endruleset;
endruleset;

--- encrypt and decrypt rules of pat: aenc(Nb,pk(B)), for intruder
ruleset i:indexType do 
  rule "decrypt 8"	---pat8
    i<=pat8Set.length & Spy_known[pat8Set.content[i]] &
    !Spy_known[msgs[pat8Set.content[i]].aencMsg]
    ==>
    var key_inv:Message;
	msgPat1:indexType;
	flag_pat1:boolean;
    begin
      key_inv := inverseKey(msgs[msgs[pat8Set.content[i]].aencKey]);
      if (key_inv.k.ag = intruderType) then
        Spy_known[msgs[pat8Set.content[i]].aencMsg]:=true;
        msgPat1:=msgs[pat8Set.content[i]].aencMsg;
        isPat1(msgs[msgPat1],flag_pat1);
        if (flag_pat1) then
          if (!exist(pat1Set,msgPat1)) then
            pat1Set.length:=pat1Set.length+1;
            pat1Set.content[pat1Set.length]:=msgPat1;
          endif;
        endif;
      endif;
    end;
endruleset;

ruleset i:indexType do 
  ruleset j:indexType do 
    rule "encrypt 8"	---pat8
      i<=pat1Set.length & Spy_known[pat1Set.content[i]] &
      j<=pat4Set.length & Spy_known[pat4Set.content[j]] &
      !Spy_known[construct8By14(pat1Set.content[i],pat4Set.content[j])]
      ==>
      var encMsgNo:indexType;
	  ---encMsg:Message;
      begin
        if (msgs[pat4Set.content[j]].k.ag=intruder.B) then
          encMsgNo := construct8By14(pat1Set.content[i],pat4Set.content[j]);
          if (!exist(pat8Set,encMsgNo)) then
            pat8Set.length := pat8Set.length+1;
            pat8Set.content[pat8Set.length]:=encMsgNo;
          endif;
          if (!Spy_known[encMsgNo]) then
            Spy_known[encMsgNo] := true;
          endif;
        endif;
      end;
    end;
  endruleset;
endruleset;


